var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [PartonDensity]","category":"page"},{"location":"api/#PartonDensity.PDFParameters","page":"API","title":"PartonDensity.PDFParameters","text":"PDFParameters\n\nParameters of the input PDFs.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QCDNUMGrid","page":"API","title":"PartonDensity.QCDNUMGrid","text":"QCDNUMGrid\n\nStruct for holding the QCDNUM grid parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QCDNUMParameters","page":"API","title":"PartonDensity.QCDNUMParameters","text":"QCDNUMParameters\n\nStruct for holding all QCDNUM Parameters. \n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.QuarkCoefficients","page":"API","title":"PartonDensity.QuarkCoefficients","text":"QuarkCoefficients\n\nQuark coefficients for structure function  calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.SPLINTParameters","page":"API","title":"PartonDensity.SPLINTParameters","text":"SPLINTParameters\n\nStruct for storage of parameters used with SPLINT package of QCDNUM.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity.SplineAddresses","page":"API","title":"PartonDensity.SplineAddresses","text":"SplineAddresses\n\nLookup table for addresses of different  structure function splines.\n\n\n\n\n\n","category":"type"},{"location":"api/#PartonDensity._fun_xsec_i-Tuple{Any, Any}","page":"API","title":"PartonDensity._fun_xsec_i","text":"_fun_xsec_i(ix iq)\n\nInput function for cross section spline. Must be wrapped for interface to SPLINT.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2-Tuple{Array{Float64, N} where N, Array{Float64, N} where N}","page":"API","title":"PartonDensity.dd_xsecnc_xq2","text":"dd_xsecnc_xq2(x_bin_cen, q2_bin_cen)\n\nDouble differential cross section for all x and  q2 bins. NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.dd_xsecnc_xq2_i-NTuple{5, Float64}","page":"API","title":"PartonDensity.dd_xsecnc_xq2_i","text":"dd_xsecnc_xq2_i(x, q2)\n\nDouble differential cross section for single  x and q2 values.  NB: modifications needed to include pol and order.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.f2_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.f2_lo","text":"f2_lo(x, q2)\n\nCalculate the f2_lo structure function term.  To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.fl_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.fl_lo","text":"fl_lo(x, q2)\n\nCalculate the fl_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.int_xtotx-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Array{Float64, N} where N}","page":"API","title":"PartonDensity.int_xtotx","text":"int_xtotx(λ_u, K_u, λ_d, K_d, λ_g1, λ_g2, K_g, λ_q, θ)\n\nTotal integrated momentum density. Should equal 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.int_xtotx-Tuple{PDFParameters}","page":"API","title":"PartonDensity.int_xtotx","text":"int_xtotx(hyper_params)\n\nTotal integrated momentum density. Should equal 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.nc_propagator-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.nc_propagator","text":"nc_propagator(q2, x)\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.plot_input_pdfs","page":"API","title":"PartonDensity.plot_input_pdfs","text":"plot_input_pdfs(hyper_params, xmin, xmax, nx)\n\nPlot the input PDFs defined by hyper_params over  the given x range.   \n\n\n\n\n\n","category":"function"},{"location":"api/#PartonDensity.rxsecnc_xq2-Tuple{Array{Float64, N} where N, Array{Float64, N} where N}","page":"API","title":"PartonDensity.rxsecnc_xq2","text":"rxsecnc_xq2(x, q2)\n\nReduced cross section for all bins.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.rxsecnc_xq2_i-NTuple{5, Float64}","page":"API","title":"PartonDensity.rxsecnc_xq2_i","text":"rxsecnc_xq2_i(x, q2)\n\nReduced cross section for single x, q2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_dv_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_dv_x","text":"x_dv_x(x, λ_d, K_d)\n\nMomentum density of d valence component. Beta function     Ad x^λd (1 - x)^Kd Ad is set by λd and Kd.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_g_x-NTuple{6, Float64}","page":"API","title":"PartonDensity.x_g_x","text":"    x_g_x(x, λ_g1, λ_g2, K_g, w1, w2)\n\nMomentum density of gluon component.     Ag1 x^λg1 (1 - x)^Kg + Ag2 x^λ_g2 Amplitudes are set by weights w1 and w2.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_q_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_q_x","text":"x_q_x(x, λ_q, w)\n\nMomentum density of non-valence quark component.     Aq x^λq Amplitude is set by weight w\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.x_uv_x-Tuple{Float64, Float64, Float64}","page":"API","title":"PartonDensity.x_uv_x","text":"x_uv_x(x, λ_u, K_u)\n\nMomentum density of u valence component. Beta function      Au x^λu (1-x)^Ku Au is set by λu and Ku.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xf3_lo-Tuple{Float64, Float64}","page":"API","title":"PartonDensity.xf3_lo","text":"xf3_lo(x, q2)\n\nCalculate the xf3_lo structure function term. To be run after the evolution of PDFs with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"api/#PartonDensity.xtotx-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Array{Float64, N} where N}","page":"API","title":"PartonDensity.xtotx","text":"x_total_x(x, λ_u, K_u, λ_d, K_d, λ_g1, λ_g2, K_g, λ_q, θ)\n\nTotal momentum density.\n\n\n\n\n\n","category":"method"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/master/examples/transfer_matrix.jl\"","category":"page"},{"location":"transfer_matrix/#Transfer-matrix","page":"Transfer matrix","title":"Transfer matrix","text":"","category":"section"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Here is a short demonstration of how to access the ZEUS transfer matrix interface.","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"using PartonDensity, CSV, DelimitedFiles\n\neMPp = 1 # e+/e- switch 0/1","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Read in an example integrated cross section","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"numbers_from_file = readdlm(\"data/HERAPDF20_NNLO_EIG_ePp.txt\")","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"List of integrated cross section values in 429 bins","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"integ_xsec = numbers_from_file[:,3]","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"Corresponding list of expected event numbers","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"prediction = get_pred_N(integ_xsec, eMPp);\n\ninteg_xsec[153]\n\nprediction[151]","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"","category":"page"},{"location":"transfer_matrix/","page":"Transfer matrix","title":"Transfer matrix","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/master/examples/pdf_parametrisation.jl\"","category":"page"},{"location":"pdf_parametrisation/#Input-PDF-parametrisation-and-priors","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"An important part of PDF fitting is defining a useful parametrisation for the PDF shapes, as well as meaningful prior distributions that encode our knowledge of the problem.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"In this notebook, we explore two different approaches:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Full Dirichlet\nValence shape + Dirichlet","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"In the end, it seems like the latter option makes more sense for us and is therefore implemented elsewhere in the PartonDensity package. We demonstrate why below.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using Distributions, Plots, SpecialFunctions, Printf\nconst sf = SpecialFunctions;\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/#\"Full-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Full Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A clean way to ensure the momentum sum rule would be to sample different contributions of the momentrum density integral from a Dirichlet distribution, then use these weights to set the parameters on the individual Beta distributions. However, in practice this is non-trvial as we also want to fix the normalisation of the number densities of the valance contributions.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"9 components of decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"dirichlet = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1, 0.1, 0.1])\ndata = rand(dirichlet, 1000);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Have a look","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"plot()\nfor i in 1:9\n    histogram!(data[i,:], bins=range(0, stop=1, length=20), alpha=0.7)\nend\nh = plot!(xlabel=\"I_i = A_i B_i\");\ndisplay(h)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This would be great as the sum rule is automatically conserved","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"sum(data, dims=1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"But, it is non-trival to define valence params from this","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I = rand(dirichlet)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Valance u component","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = rand(Uniform(0, 1))\nK_u = rand(Uniform(0, 10))","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral of number density must = 2","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"A_u = 2 / sf.beta(λ_u, K_u+1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"integral of momentum density can be fixed by I[1]","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_1 = A_u * sf.beta(λ_u+1, K_u+1);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Could use a root-finder to find Ku given I1 and λ_u... Could be nasty to sample from though...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_1 = 2 * (sf.beta(λ_u+1, K_u+1)/sf.beta(λ_u, K_u+1));\n\nusing Roots\n\nfunction func_to_solve(K_u)\n    return I_1 - 2 * (sf.beta(λ_u+1, K_u+1) / sf.beta(λ_u, K_u+1))\nend\n\nK_u ≈ find_zero(func_to_solve, (0, 10), Bisection())","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"While this approach might be nice, there are two issues in practice:","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"It is difficult to set sensible priors on lambda_u that imply priors","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"on K_u, and similarly for lambda_d and K_d","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"The problem is overconstrained and we hav to use a root finder.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This is rather fragile, and could fail for certain parameter combinations, such as we might find in a fit.","category":"page"},{"location":"pdf_parametrisation/#\"Valence-shape-Dirichlet\"-approach","page":"Input PDF parametrisation and priors","title":"\"Valence shape + Dirichlet\" approach","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We can handle this more elegantly (maybe?) by specifying constraints on the valence params through the shape of their Beta distributions, then using a Dirichlet to specify the weights of the gluon and sea components. The problem here is it isn't clear how to specify that the d contribution must be less than the u contribution, but it is possible to do this indirectly through priors on the shape parameters. This will however require some further investigation.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = range(0, stop=1, length=50)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"High-level priors Looks like we maybe want to change lambda and K priors to boost these components","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_u = 0.7 #rand(Uniform(0, 1))\nK_u = 4 #rand(Uniform(2, 10))\nλ_d = 0.5 #rand(Uniform(0, 1))\nK_d = 6 #rand(Uniform(2, 10))\n\nu_V = Beta(λ_u, K_u+1)\nA_u = 2 / sf.beta(λ_u, K_u+1)\n\nd_V = Beta(λ_d, K_d+1)\nA_d = 1 / sf.beta(λ_d, K_d+1)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Integral contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"I_u = A_u * sf.beta(λ_u+1, K_u+1)\nI_d = A_d * sf.beta(λ_d+1, K_d+1)\n\nplot(x, x.*pdf(u_V, x)*2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x.*pdf(d_V, x), alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:topright)\n\n@printf(\"I_u = %.2f\\n\", I_u)\n@printf(\"I_d = %.2f\\n\", I_d)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"The remaining 7 integrals can be dirichlet-sampled with decreasing importance","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"remaining = 1 - (I_u + I_d)\ndirichlet = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1])\nI = rand(dirichlet) * remaining;\nsum(I) ≈ remaining","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Gluon contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_g1 = rand(Uniform(-1, 0))\nλ_g2 = rand(Uniform(0, 1))\nK_g = rand(Uniform(2, 10))\nA_g2 = I[1] / sf.beta(λ_g2+1, K_g+1)\nA_g1 = I[2] / sf.beta(λ_g1+1, 5+1);\nnothing #hide","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Sea quark contributions","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"λ_q = rand(Uniform(-1, 0))\nA_ubar = I[3] / (2 * sf.beta(λ_q+1, 5+1))\nA_dbar = I[4] / (2 * sf.beta(λ_q+1, 5+1))\nA_s = I[5] / (2 * sf.beta(λ_q+1, 5+1))\nA_c = I[6] / (2 * sf.beta(λ_q+1, 5+1))\nA_b = I[7] / (2 * sf.beta(λ_q+1, 5+1));\n\ntotal = A_u * sf.beta(λ_u+1, K_u+1) + A_d * sf.beta(λ_d+1, K_d+1)\ntotal += A_g1 * sf.beta(λ_g1+1, 5+1) + A_g2 * sf.beta(λ_g2+1, K_g+1)\ntotal += 2 * (A_ubar + A_dbar + A_s + A_c + A_b) * sf.beta(λ_q+1, 5+1)\ntotal ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"x = 10 .^ range(-2, stop=0, length=500)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"How does it look?","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"xg2 = A_g2 * x.^λ_g2 .* (1 .- x).^K_g\nxg1 = A_g1 * x.^λ_g1 .* (1 .-x).^5\nplot(x, x.*pdf(u_V, x)*2, alpha=0.7, label=\"x u(x)\", lw=3)\nplot!(x, x.*pdf(d_V, x), alpha=0.7, label=\"x d(x)\", lw=3)\nplot!(x, xg1 + xg2, alpha=0.7, label=\"x g(x)\", lw=3)\nplot!(x, A_ubar * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x ubar(x)\", lw=3)\nplot!(x, A_dbar * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x dbar(x)\", lw=3)\nplot!(x, A_s * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x s(x)\", lw=3)\nplot!(x, A_c * x.^λ_q .* (1.0 .- x).^5, alpha=0.7, label=\"x c(x)\", lw=3)\nplot!(x, A_b * x.^λ_q .* (1.0 .-  x).^5, alpha=0.7, label=\"x b(x)\", lw=3)\nplot!(xlabel=\"x\", legend=:bottomleft, xscale=:log, ylims=(1e-8, 10), yscale=:log)","category":"page"},{"location":"pdf_parametrisation/#Prior-predictive-checks","page":"Input PDF parametrisation and priors","title":"Prior predictive checks","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"We can start to visualise the type of PDFs that are allowed by the combination of the choice of parametrisation and prior distributions with some simple prior predictive checks, as done below...","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"N = 100\nalpha = 0.03\ntotal = Array{Float64, 1}(undef, N)\nfirst = true\nleg = 0\n\nplot()\nfor i in 1:N\n\n    λ_u = rand(Uniform(0, 1))\n    K_u = rand(Uniform(2, 10))\n    λ_d = rand(Uniform(0, 1))\n    K_d = rand(Uniform(2, 10))\n    A_u = 2 / sf.beta(λ_u, K_u+1)\n    A_d = 1 / sf.beta(λ_d, K_d+1)\n    I_u = A_u * sf.beta(λ_u+1, K_u+1)\n    I_d = A_d * sf.beta(λ_d+1, K_d+1)\n    u_V = Beta(λ_u, K_u+1)\n    d_V = Beta(λ_d, K_d+1)\n\n    remaining = 1 - (I_u + I_d)\n    dirichlet = Dirichlet([3., 2., 1, 0.5, 0.3, 0.2, 0.1])\n    I = rand(dirichlet) * remaining\n\n    λ_g1 = rand(Uniform(-1, 0))\n    λ_g2 = rand(Uniform(0, 1))\n    K_g = rand(Uniform(2, 10))\n    A_g2 = I[1] / sf.beta(λ_g2+1, K_g+1)\n    A_g1 = I[2] / sf.beta(λ_g1+1, 5+1)\n\n    λ_q = rand(Uniform(-1, 0))\n    A_ubar = I[3] / (2 * sf.beta(λ_q+1, 5+1))\n    A_dbar = I[4] / (2 * sf.beta(λ_q+1, 5+1))\n    A_s = I[5] / (2 * sf.beta(λ_q+1, 5+1))\n    A_c = I[6] / (2 * sf.beta(λ_q+1, 5+1))\n    A_b = I[7] / (2 * sf.beta(λ_q+1, 5+1))\n\n    total[i] = A_u * sf.beta(λ_u+1, K_u+1) + A_d * sf.beta(λ_d+1, K_d+1)\n    total[i] += A_g1 * sf.beta(λ_g1+1, 5+1) + A_g2 * sf.beta(λ_g2+1, K_g+1)\n    total[i] += 2 * (A_ubar + A_dbar + A_s + A_c + A_b) * sf.beta(λ_q+1, 5+1)\n\n    xg2 = A_g2 * x.^λ_g2 .* (1 .- x).^K_g\n    xg1 = A_g1 * x.^λ_g1 .* (1 .- x).^5\n    plot!(x, x.*pdf(u_V, x)*2, alpha=alpha, color=\"blue\", lw=3)\n    plot!(x, x.*pdf(d_V, x), alpha=alpha, color=\"orange\", lw=3)\n    plot!(x, xg1 + xg2, alpha=alpha, color=\"green\", lw=3)\n    plot!(x, A_ubar * x.^λ_q .* (1 .- x).^5, alpha=alpha, color=\"red\", lw=3)\n    plot!(x, A_dbar * x.^λ_q .* (1 .- x).^5, alpha=alpha, color=\"purple\", lw=3)\n    plot!(x, A_s * x.^λ_q .* (1 .- x).^5, alpha=alpha, color=\"brown\", lw=3)\n    plot!(x, A_c * x.^λ_q .* (1 .- x).^5, alpha=alpha, color=\"pink\", lw=3)\n    plot!(x, A_b * x.^λ_q .* (1 .- x).^5, alpha=alpha, color=\"grey\", lw=3)\nend\n\nh = plot!(xlabel=\"x\", ylabel=\"x f(x)\", xscale=:log, legend=false,\n    ylims=(1e-8, 10), yscale=:log)\ndisplay(h)","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"Looks like naive priors need some work...","category":"page"},{"location":"pdf_parametrisation/#PDF-Parametrisation-interface","page":"Input PDF parametrisation and priors","title":"PDF Parametrisation interface","text":"","category":"section"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"PartonDensity provides a handy interface to the \"Valence shape + Dirichlet\" style parametrisation, as demonstrated here.","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"using PartonDensity\n\nhyper_params = PDFParameters(λ_u=0.5, K_u=4.0, λ_d=0.6, K_d=6.0, λ_g1=-0.37, λ_g2=-0.7,\n                             K_g=6.0, λ_q=0.5, seed=5, weights=[50., 0.5, 5., 5., 3., 2., 1.]);\n\nplot_input_pdfs(hyper_params)\n\nint_xtotx(hyper_params) ≈ 1","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"","category":"page"},{"location":"pdf_parametrisation/","page":"Input PDF parametrisation and priors","title":"Input PDF parametrisation and priors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/cescalara/PartonDensity.jl/blob/master/examples/forward_model.jl\"","category":"page"},{"location":"forward_model/#Forward-model","page":"Forward model","title":"Forward model","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Here, we go through an example of simulating the full forward model, from the prior definition to the expected number of events in different bins of the detector response.","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"using QCDNUM, PartonDensity\nusing Plots, Printf, NaNMath, Parameters","category":"page"},{"location":"forward_model/#Define-input-PDFs","page":"Forward model","title":"Define input PDFs","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"weights = [50., 0.5, 5., 5., 3., 2., 1.]\nhyper_params = PDFParameters(λ_u=0.5, K_u=4.0, λ_d=0.6, K_d=6.0, λ_g1=-0.37, λ_g2=-0.7,\n                             K_g=6.0, λ_q=0.5, seed=5, weights=weights);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Plot the input PDFs","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot_input_pdfs(hyper_params)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Sanity check that sum = 1","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"int_xtotx(hyper_params) ≈ 1","category":"page"},{"location":"forward_model/#Define-QCDNUM-grids,-weights-and-settings","page":"Forward model","title":"Define QCDNUM grids, weights and settings","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"grid = QCDNUMGrid(x_min=[1.0e-3], x_weights=[1], nx=100,\n                  qq_bounds=[1.0e2, 3.0e4], qq_weights=[1.0, 1.0], nq=50, spline_interp=3)\n\nqcdnum_params = QCDNUMParameters(order=2, α_S=0.118, q0=100.0, grid=grid,\n                                 n_fixed_flav=5, iqc=1, iqb=1, iqt=1, weight_type=1);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Initialise and set key parameters","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.qcinit(-6, \"\")\nQCDNUM.setord(qcdnum_params.order)\nQCDNUM.setalf(qcdnum_params.α_S, qcdnum_params.q0)","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Build grids","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"g = qcdnum_params.grid\nQCDNUM.gxmake(g.x_min, g.x_weights, g.x_num_bounds, g.nx,\n              g.spline_interp);\nQCDNUM.gqmake(g.qq_bounds, g.qq_weights, g.qq_num_bounds, g.nq);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define FFNS/VFNS","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.setcbt(qcdnum_params.n_fixed_flav, qcdnum_params.iqc,\n              qcdnum_params.iqb, qcdnum_params.iqt);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Build weight tables","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"nw = QCDNUM.fillwt(qcdnum_params.weight_type)\nnw = QCDNUM.zmfillw()","category":"page"},{"location":"forward_model/#Evolve-the-PDFs-using-QCDNUM","page":"Forward model","title":"Evolve the PDFs using QCDNUM","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define input PDF function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"See https://www.nikhef.nl/~h24/qcdnum-files/doc/qcdnum170115.pdf under evolfg","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"There are functions available to generate the necessary input PDF function in the correct format for QCDNUM.jl (see get_input_pdf_func()), along with the mapping between this input function and quark species (see input_pdf_map).","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Get function and wrap with c-style pointer","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"my_func = get_input_pdf_func(hyper_params)\ninput_pdf = @cfunction(my_func, Float64, (Ref{Int32}, Ref{Float64}))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Find index of starting scale and evolve","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iq0 = QCDNUM.iqfrmq(qcdnum_params.q0)\npdf_loc = 1\neps = QCDNUM.evolfg(pdf_loc, input_pdf, input_pdf_map, iq0)","category":"page"},{"location":"forward_model/#Define-necessary-splines-for-cross-section-calculation","page":"Forward model","title":"Define necessary splines for cross section calculation","text":"","category":"section"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"For splines","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"splint_params = SPLINTParameters();\nquark_coeffs = QuarkCoefficients();\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Define initial spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_spinit(splint_params.nuser);\nia = QCDNUM.isp_s2make(splint_params.nsteps_x, splint_params.nsteps_q);\nxnd = QCDNUM.ssp_unodes(ia, splint_params.nnodes_x, 0);\nqnd = QCDNUM.ssp_vnodes(ia, splint_params.nnodes_q, 0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Check nodes and erase","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_nprint(ia);\nQCDNUM.ssp_erase(ia);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"Set nodes and fill spline with structure function","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"iaFLup = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLup, pdf_loc, quark_coeffs.proup, 1, 0.0);\n\niaF2up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2up, pdf_loc, quark_coeffs.proup, 2, 0.0);\n\niaF3up = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3up, pdf_loc, quark_coeffs.valup, 3, 0.0);\n\niaFLdn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaFLdn, pdf_loc, quark_coeffs.prodn, 1, 0.0);\n\niaF2dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF2dn, pdf_loc, quark_coeffs.prodn, 2, 0.0);\n\niaF3dn = QCDNUM.isp_s2user(xnd, splint_params.nnodes_x, qnd, splint_params.nnodes_q);\nQCDNUM.ssp_s2f123(iaF3dn, 1, quark_coeffs.valdn, 3, 0.0);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"store spline addresses","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"QCDNUM.ssp_uwrite(splint_params.spline_addresses.F2up, Float64(iaF2up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F2dn, Float64(iaF2dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3up, Float64(iaF3up));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F3dn, Float64(iaF3dn));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLup, Float64(iaFLup));\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.FLdn, Float64(iaFLdn));\n\nmy_func = get_input_xsec_func()\ninput_xsec = @cfunction(my_func, Float64, (Ref{Int32}, Ref{Int32}, Ref{UInt8}))","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"xsec_on_grid = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        xsec_on_grid[ix, iq] = _fun_xsec_i(ix, iq)\n    end\nend\n\nqcdnum_x_grid = QCDNUM.gxcopy(g.nx)\nqcdnum_qq_grid =  QCDNUM.gqcopy(g.nq)\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(xsec_on_grid[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n    xaxis=:log, yaxis=:log)\n\nplot(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 4]),\n    label=\"Q2=141 (input scale)\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 22]), label=\"Q2=1152\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 35]), label=\"Q2=5233\", lw=3)\nplot!(qcdnum_x_grid, NaNMath.log10.(xsec_on_grid[:, 41]), label=\"Q2=10523\", lw=3)\nplot!(xaxis=:log, legend=:bottomleft, xlabel=\"x\",\n    ylabel=\"log10(cross section spline input)\", ylims=(-7, 5))\n\nset_lepcharge(1)\niaF_eP = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eP, Float64(iaF_eP));\nQCDNUM.ssp_s2fill(iaF_eP, input_xsec, splint_params.rscut);\n\nset_lepcharge(-1)\niaF_eM = QCDNUM.isp_s2make(1, 2);\nQCDNUM.ssp_uwrite(splint_params.spline_addresses.F_eM, Float64(iaF_eM));\nQCDNUM.ssp_s2fill(iaF_eM, input_xsec, splint_params.rscut);\nnothing #hide","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"plot spline","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"spline = zeros(g.nx, g.nq);\n\nfor ix = 1:g.nx\n    for iq = 1:g.nq\n        spline[ix, iq] = QCDNUM.dsp_funs2(iaF_eP, qcdnum_x_grid[ix],\n            qcdnum_qq_grid[iq], 1)\n    end\nend\n\np1 = heatmap(qcdnum_x_grid, qcdnum_qq_grid, NaNMath.log10.(spline[:, :]'))\nplot(p1, xlabel=\"x\", ylabel=\"q2\",\n    xaxis=:log, yaxis=:log)\n\n# Integrate over the cross section spline and find expected events numbers\n\nnbins = size(xbins_M_begin)[1]\nIntXsec_eP = zeros(nbins);\nIntXsec_eM = zeros(nbins);\nfor i in 1:nbins\n    IntXsec_eP[i] = QCDNUM.dsp_ints2(iaF_eP, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318., 4);\n    IntXsec_eM[i] = QCDNUM.dsp_ints2(iaF_eM, xbins_M_begin[i], xbins_M_end[i],\n        q2bins_M_begin[i], q2bins_M_end[i], 318., 4);\nend","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"1 for e-p and 0 for e+p","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"ePp = 0;\neMp = 1;\n\nTM_eP = get_TM_elements(ePp);\nTM_eM = get_TM_elements(eMp);\n\nK_eP = get_K_elements(ePp);\nK_eM = get_K_elements(eMp);\n\nnbins_out = size(TM_eP)[2];\n\nxsec_pred_eP = zeros(nbins_out);\nxsec_pred_eM = zeros(nbins_out);\n\nfor j in 1:nbins_out\n\n    for i in 1:nbins\n\n        xsec_pred_eP[j] += TM_eP[i, j] * (1.0/K_eP[i]) * IntXsec_eP[i];\n        xsec_pred_eM[j] += TM_eM[i, j] * (1.0/K_eM[i]) * IntXsec_eM[i];\n\n    end\n\nend\n\nxsec_pred_eM","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"forward_model/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Bayesian approach to parton density extraction. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hadrons, such as protons and neutrons, are made up of quarks held together by the strong force. At high energy scales, the valence quarks that define these hadrons exist in a sea of virtual quarks and gluons. The parton distribution functions (PDFs) describe this structure and are of fundamental importance to our understanding of quantum chromodynamics (QCD), as well as its application to LHC physics and the development of cosmic ray air showers in the Earth's atmosphere. PDFs can be extracted from accelerator measurements in which hadrons are probed through collisions with electrons. A limitation of existing approaches to analysing this data is the reliance on the chi-square statistic and the coupled assumption of Normal-distributed observations. We are working on a new statistical method for PDF extraction, which overcomes this limitation by forward modelling the problem from an input PDF to the expected number of events in a detector. This model will then be fit using Markov Chain Monte Carlo to enable inference of the PDF parameters. Our project builds on the QCDNUM software for fast QCD evolution and the Bayesian Analysis Toolkit developed at the ODSL to allow inference. We initially focus on the \"high-x\" regime, where the chi-square method cannot be used due to low event numbers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package uses QCDNUM.jl for fast PDF evolution and cross-section calculation and BAT.jl for Bayesian inference.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install PartonDensity.jl, start Julia and run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> pkg\"add https://github.com/cescalara/PartonDensity.jl.git\"","category":"page"},{"location":"#Development","page":"Introduction","title":"Development","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Below are the installation instruction for those who wish to contribute to the code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Clone the github repository, e.g. via the command line:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"git clone  https://github.com/cescalara/QCDNUM.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Enter the directory and start Julia interpreter","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"cd QCDNUM.jl\njulia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Open the Julia package management environment pressing .","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> ]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Execute ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> generate QCDNUM\n...... \npkg>  . dev","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Exit the package manager using backspace or pressing Ctrl+C","category":"page"}]
}
